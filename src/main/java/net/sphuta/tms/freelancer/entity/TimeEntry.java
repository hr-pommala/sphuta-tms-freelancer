package net.sphuta.tms.freelancer.entity;

import jakarta.persistence.*;
import lombok.*;
import lombok.extern.slf4j.Slf4j;             // Lombok logger
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.util.UUID;

/**
 * TimeEntry represents a single row (cell) of work logged against a Timesheet.
 * <p>
 * Key characteristics:
 * <ul>
 *   <li>Belongs to a {@link Timesheet} (many-to-one).</li>
 *   <li>Tracks hours worked, optional rate/cost snapshot, and optional start/end times.</li>
 *   <li>Audit fields (createdAt/updatedAt) are populated automatically.</li>
 * </ul>
 * <p>
 * Notes:
 * <ul>
 *   <li>Logging is added via JPA lifecycle callbacks for observability.</li>
 *   <li>No business logic is introduced here; only comments and logs.</li>
 * </ul>
 */
@Slf4j
@Entity                                                     // JPA entity
@Table(
        name = "time_entries",
        indexes = @Index(name = "idx_time_entries_date", columnList = "entry_date")
)
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
public class TimeEntry {

    /* ------------------------------- Identifier ------------------------------- */

    /** Primary key (UUID), generated by JPA provider. */
    @Id
    @GeneratedValue
    private UUID id;

    /* ------------------------------- Relations -------------------------------- */

    /**
     * Owning timesheet (many entries per timesheet).
     * <p>
     * LAZY to avoid unnecessary loading when only entry fields are needed.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "timesheet_id", nullable = false)    // FK column
    private Timesheet timesheet;

    /* --------------------------------- Data ----------------------------------- */

    /** Calendar date this work was performed (part of the timesheet period). */
    @Column(name = "entry_date", nullable = false)
    private LocalDate entryDate;

    /** Optional free-text description of the work done. */
    private String description;

    /**
     * Quantity of time worked for this entry.
     * <p>
     * Stored as NUMERIC(6,2) to support quarter-hour increments and limit magnitude.
     * Validations (e.g., > 0, <= 24) are enforced at service/DTO layers.
     */
    @Column(nullable = false, precision = 6, scale = 2)
    private BigDecimal hours;

    /**
     * Optional start clock time (with offset). May be auto-filled server-side.
     * This field is not required in the create request body.
     */
    @Column(name = "start_time")
    private OffsetTime startTime;

    /**
     * Optional end clock time (with offset). May be auto-filled server-side.
     * Should be after {@link #startTime} when both are present.
     */
    @Column(name = "end_time")
    private OffsetTime endTime;

    /**
     * Hourly rate snapshot captured at the time of entry (optional).
     * Useful for historical reporting even if rates change later.
     */
    @Column(name = "rate_at_entry", precision = 10, scale = 2)
    private BigDecimal rateAtEntry;

    /**
     * Cost snapshot for this entry: typically {@code hours * rateAtEntry}.
     * Calculated and stored at creation/update time for reporting performance.
     */
    @Column(name = "cost_at_entry", precision = 12, scale = 2)
    private BigDecimal costAtEntry;

    /* --------------------------------- Audit ---------------------------------- */

    /**
     * Timestamp when this entry was created.
     * Populated automatically by Hibernate.
     */
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private OffsetDateTime createdAt;

    /**
     * Timestamp when this entry was last updated.
     * Populated automatically by Hibernate.
     */
    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt;

    /* ------------------------------- Lifecycle -------------------------------- */

    /**
     * JPA lifecycle callback before the entity is persisted.
     * Used only for logging (no business logic).
     */
    @PrePersist
    private void onPrePersist() {
        // Block-level comment: pre-persist log conveys the essential identity & core fields.
        if (log.isDebugEnabled()) {
            log.debug("PrePersist TimeEntry: id={}, timesheetId={}, entryDate={}, hours={}, rateAtEntry={}, startTime={}, endTime={}",
                    id,
                    timesheet != null ? timesheet.getId() : null,
                    entryDate,
                    hours,
                    rateAtEntry,
                    startTime,
                    endTime
            );
        }
    }

    /**
     * JPA lifecycle callback after the entity is persisted.
     * Used only for logging (no business logic).
     */
    @PostPersist
    private void onPostPersist() {
        if (log.isInfoEnabled()) {
            log.info("Persisted TimeEntry: id={}, timesheetId={}, entryDate={}, hours={}, costAtEntry={}",
                    id,
                    timesheet != null ? timesheet.getId() : null,
                    entryDate,
                    hours,
                    costAtEntry
            );
        }
    }

    /**
     * JPA lifecycle callback before the entity is updated.
     * Used only for logging (no business logic).
     */
    @PreUpdate
    private void onPreUpdate() {
        if (log.isDebugEnabled()) {
            log.debug("PreUpdate TimeEntry: id={}, entryDate={}, hours={}, rateAtEntry={}, startTime={}, endTime={}",
                    id, entryDate, hours, rateAtEntry, startTime, endTime);
        }
    }

    /**
     * JPA lifecycle callback after the entity is loaded.
     * Useful to trace lazy loading in development.
     */
    @PostLoad
    private void onPostLoad() {
        if (log.isTraceEnabled()) {
            log.trace("Loaded TimeEntry: id={}, entryDate={}, hours={}", id, entryDate, hours);
        }
    }
}
